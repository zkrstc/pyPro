{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport { isEqual } from 'lodash-unified';\nimport Node from './node.mjs';\nconst flatNodes = (nodes, leafOnly) => {\n  return nodes.reduce((res, node) => {\n    if (node.isLeaf) {\n      res.push(node);\n    } else {\n      !leafOnly && res.push(node);\n      res = res.concat(flatNodes(node.children, leafOnly));\n    }\n    return res;\n  }, []);\n};\nclass Store {\n  constructor(data, config) {\n    this.config = config;\n    const nodes = (data || []).map(nodeData => new Node(nodeData, this.config));\n    this.nodes = nodes;\n    this.allNodes = flatNodes(nodes, false);\n    this.leafNodes = flatNodes(nodes, true);\n  }\n  getNodes() {\n    return this.nodes;\n  }\n  getFlattedNodes(leafOnly) {\n    return leafOnly ? this.leafNodes : this.allNodes;\n  }\n  appendNode(nodeData, parentNode) {\n    const node = parentNode ? parentNode.appendChild(nodeData) : new Node(nodeData, this.config);\n    if (!parentNode) this.nodes.push(node);\n    this.appendAllNodesAndLeafNodes(node);\n  }\n  appendNodes(nodeDataList, parentNode) {\n    nodeDataList.forEach(nodeData => this.appendNode(nodeData, parentNode));\n  }\n  appendAllNodesAndLeafNodes(node) {\n    this.allNodes.push(node);\n    node.isLeaf && this.leafNodes.push(node);\n    if (node.children) {\n      node.children.forEach(subNode => {\n        this.appendAllNodesAndLeafNodes(subNode);\n      });\n    }\n  }\n  getNodeByValue(value, leafOnly = false) {\n    if (!value && value !== 0) return null;\n    const node = this.getFlattedNodes(leafOnly).find(node2 => isEqual(node2.value, value) || isEqual(node2.pathValues, value));\n    return node || null;\n  }\n  getSameNode(node) {\n    if (!node) return null;\n    const node_ = this.getFlattedNodes(false).find(({\n      value,\n      level\n    }) => isEqual(node.value, value) && node.level === level);\n    return node_ || null;\n  }\n}\nexport { Store as default };","map":{"version":3,"names":["flatNodes","nodes","leafOnly","reduce","res","node","isLeaf","push","concat","children","Store","constructor","data","config","map","nodeData","Node","allNodes","leafNodes","getNodes","getFlattedNodes","appendNode","parentNode","appendChild","appendAllNodesAndLeafNodes","appendNodes","nodeDataList","forEach","subNode","getNodeByValue","value","find","node2","isEqual","pathValues","getSameNode","node_","level"],"sources":["../../../../../../packages/components/cascader-panel/src/store.ts"],"sourcesContent":["import { isEqual } from 'lodash-unified'\nimport Node from './node'\n\nimport type { Nullable } from '@element-plus/utils'\nimport type {\n  CascaderConfig,\n  CascaderNodePathValue,\n  CascaderNodeValue,\n  CascaderOption,\n} from './node'\n\nconst flatNodes = (nodes: Node[], leafOnly: boolean) => {\n  return nodes.reduce((res, node) => {\n    if (node.isLeaf) {\n      res.push(node)\n    } else {\n      !leafOnly && res.push(node)\n      res = res.concat(flatNodes(node.children, leafOnly))\n    }\n    return res\n  }, [] as Node[])\n}\n\nexport default class Store {\n  readonly nodes: Node[]\n  readonly allNodes: Node[]\n  readonly leafNodes: Node[]\n\n  constructor(data: CascaderOption[], readonly config: CascaderConfig) {\n    const nodes = (data || []).map(\n      (nodeData) => new Node(nodeData, this.config)\n    )\n    this.nodes = nodes\n    this.allNodes = flatNodes(nodes, false)\n    this.leafNodes = flatNodes(nodes, true)\n  }\n\n  getNodes() {\n    return this.nodes\n  }\n\n  getFlattedNodes(leafOnly: boolean) {\n    return leafOnly ? this.leafNodes : this.allNodes\n  }\n\n  appendNode(nodeData: CascaderOption, parentNode?: Node) {\n    const node = parentNode\n      ? parentNode.appendChild(nodeData)\n      : new Node(nodeData, this.config)\n\n    if (!parentNode) this.nodes.push(node)\n\n    this.appendAllNodesAndLeafNodes(node)\n  }\n\n  appendNodes(nodeDataList: CascaderOption[], parentNode: Node) {\n    nodeDataList.forEach((nodeData) => this.appendNode(nodeData, parentNode))\n  }\n\n  appendAllNodesAndLeafNodes(node: Node) {\n    this.allNodes.push(node)\n    node.isLeaf && this.leafNodes.push(node)\n    if (node.children) {\n      node.children.forEach((subNode) => {\n        this.appendAllNodesAndLeafNodes(subNode)\n      })\n    }\n  }\n\n  // when checkStrictly, leaf node first\n  getNodeByValue(\n    value: CascaderNodeValue | CascaderNodePathValue,\n    leafOnly = false\n  ): Nullable<Node> {\n    if (!value && value !== 0) return null\n\n    const node = this.getFlattedNodes(leafOnly).find(\n      (node) => isEqual(node.value, value) || isEqual(node.pathValues, value)\n    )\n\n    return node || null\n  }\n\n  getSameNode(node: Node): Nullable<Node> {\n    if (!node) return null\n\n    const node_ = this.getFlattedNodes(false).find(\n      ({ value, level }) => isEqual(node.value, value) && node.level === level\n    )\n\n    return node_ || null\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}